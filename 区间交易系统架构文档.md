区间交易系统架构文档
项目概述
本项目旨在构建一个基于Python的加密货币区间交易系统，基于《项目描述.md》的自创分析框架，核心包括峰谷算法、关键价位计算、回测优化、特征工程和机器学习验证。目标是处理Binance排名前10交易对的2年5分钟K线数据（约10M+条），实现高效回测和交易规则验证，适配M2 Mac mini 8G RAM硬件，适合编程初学者，使用Poetry管理依赖，代码运行于Python 3.13，开发和验收通过Cursor多窗口Agent协作。
项目目标

数据获取：从Binance获取2023年6月1日00:00:00至2025年6月30日23:59:59的5分钟K线数据，排名前10交易对，保存为CSV。
峰谷算法：实现HL算法（g=3）和峰谷去重，确保滞后性，避免数据泄露。
关键价位：计算ATR、吸引力得分（指数衰减）、关键价位（key_1/key_0）和扩展价位。
回测优化：对w=[120,240]、band_width=[0.05,0.15]、阈值=[0.05,0.2]进行贝叶斯优化，评估夏普比率/胜率。
特征工程：提取50个峰谷的扩展价位比例和Z-Score归一化成交量。
机器学习：使用RandomForestClassifier验证交易规则，预留SMOTE样本平衡。
交易规则：模拟中性挂单（扩展价位2/-1），盈亏比3:1，手续费0.05%，动态更新。
环境配置：通过Poetry配置依赖，适配Python 3.13和ARM架构。

文件结构
采用标准Python项目结构，命名简短且具辨识度，便于GitHub管理：
interval_trading/
├── data/                    # K线数据存储
│   ├── btc_usdt_5m.csv
│   └── ... (其他交易对)
├── src/                     # 源代码
│   ├── data_acquisition.py  # 数据获取
│   ├── peak_valley.py       # 峰谷算法
│   ├── key_levels.py        # 关键价位
│   ├── backtest.py          # 回测
│   ├── features.py          # 特征工程
│   ├── ml_model.py          # 机器学习
│   ├── trading.py           # 交易规则
├── tests/                   # 测试用例
│   ├── test_data.py
│   ├── test_peak_valley.py
│   └── ...
├── pyproject.toml           # Poetry依赖
├── README.md                # 项目说明
└── .gitignore               # Git忽略文件

项目模块
以下是项目的核心模块，每个模块分解为原子化任务，包含开发和验收Prompt。
模块1: 数据获取
目标：从Binance获取排名前10交易对的5分钟K线数据，保存为CSV。

工具：CCXT（公共API），Pandas（数据处理）。
性能优化：分批拉取（1000条/次），休眠1秒，避免API限制。
安全提示：确保公共API调用，无需密钥。

模块2: 峰谷算法
目标：实现HL算法（g=3）和峰谷去重，确保滞后性，避免数据泄露。

工具：Pandas（向量化rolling）。
性能优化：全向量化计算，适配10M+数据。
安全提示：检查[n-g,n]内HL不用于最新K线。

模块3: 关键价位
目标：计算ATR、吸引力得分（指数衰减）、关键价位和扩展价位。

工具：Pandas（向量化），NumPy（指数函数）。
参数：w=[120,240]，band_width=[0.05,0.15]，阈值=[0.05,0.2]。

模块4: 回测
目标：对10个交易对回测，优化参数，输出夏普比率/胜率。

工具：scikit-optimize（贝叶斯优化），Pandas。
性能优化：分批处理，按交易对分割，向量化。

模块5: 特征工程
目标：提取50个峰谷的扩展价位比例和Z-Score归一化成交量。

工具：Pandas，Scikit-learn（SMOTE）。

模块6: 机器学习
目标：使用RandomForestClassifier验证交易规则。

工具：Scikit-learn，Pandas。

模块7: 交易规则
目标：模拟中性挂单，盈亏比3:1，手续费0.05%。

工具：Pandas（向量化模拟）。

模块8: 环境配置
目标：配置Poetry依赖，适配Python 3.13。

工具：Poetry，VS Code/Cursor。

原子任务列表
以下是每个模块的原子化任务，包含“做什么”“怎么做”、开发Prompt、验收Prompt、性能/安全提示。
模块1: 数据获取
任务1.1: 获取交易对列表

做什么：从Binance获取当前24小时成交量排名前10的交易对，确保有2年K线数据。
怎么做：
使用CCXT的load_markets获取所有交易对，筛选USDT交易对，按24小时成交量排序。
检查每个交易对的K线数据起始时间，确保包含2023年6月前数据。
输出交易对列表到data/symbols.json。


开发Prompt：为任务1.1生成Python代码，实现从Binance获取24小时成交量排名前10的USDT交易对，确保有2023年6月前5分钟K线数据。要求：
- 使用CCXT公共API，调用`load_markets`和`fetch_ohlcv`。
- 筛选USDT交易对，排序后取前10。
- 检查K线数据起始时间早于2023-06-01。
- 保存结果到`data/symbols.json`，格式为[{"symbol":"BTC/USDT","start_time":timestamp},...]。
- 包含详细注释、异常处理（API超时/连接错误）、测试用例。
- 全向量化，适配8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务1.1代码：
- 检查是否获取10个USDT交易对，排序基于24小时成交量。
- 验证每个交易对的K线数据起始时间早于2023-06-01。
- 确认`data/symbols.json`存在，格式正确，包含symbol和start_time。
- 测试代码在10M+数据下运行时间<1分钟。
- 确认无API密钥泄露风险。
输出：通过/不通过，列出问题及修改建议。


性能提示：单次API调用获取少量数据（<1000条），休眠1秒，避免触发Binance限制。
安全提示：确保公共API调用，无需密钥。

任务1.2: 拉取K线数据

做什么：为每个交易对拉取2023年6月1日-2025年6月30日的5分钟K线数据，保存为CSV。
怎么做：
使用CCXT的fetch_ohlcv，每次拉取1000条，时间范围分段（1个月/次）。
保存为data/<symbol>_5m.csv，列为[timestamp, open, high, low, close, volume]。
实现异常重试（最多3次，间隔5秒）。


开发Prompt：为任务1.2生成Python代码，为单个交易对拉取2023-06-01至2025-06-30的5分钟K线数据，保存为CSV。要求：
- 使用CCXT的`fetch_ohlcv`，每次1000条，分段处理（1个月/次）。
- 保存到`data/<symbol>_5m.csv`，列为[timestamp, open, high, low, close, volume]。
- 包含异常处理（API超时/限频，3次重试，间隔5秒）。
- 包含详细注释、测试用例（验证1000条数据）。
- 全向量化，适配8G RAM，单交易对约200MB。
输出：代码块+性能/安全提示。


验收Prompt：验证任务1.2代码：
- 检查CSV文件是否存在，列格式为[timestamp, open, high, low, close, volume]。
- 验证数据时间范围为2023-06-01至2025-06-30，无缺失。
- 测试单交易对数据量约200MB，运行时间<5分钟。
- 确认异常处理有效（模拟API超时）。
- 确认无API密钥泄露风险。
输出：通过/不通过，列出问题及修改建议。


性能提示：分段拉取（1个月/次）减少内存占用，单交易对约200MB，10个交易对约2GB。
安全提示：检查CSV文件权限，避免泄露。

模块2: 峰谷算法
任务2.1: 实现HL算法

做什么：对K线数据计算摆动高点H和低点L（g=3），标记HL点。
怎么做：
使用Pandas rolling（窗口2g+1）比较高低点，标记H（高于前后g根高点）/L（低于前后g根低点）。
输出DataFrame，新增列is_high（1表示H，0表示非H）、is_low（1表示L，0表示非L）。
确保最新K线[n-g,n]内HL不用于特征提取。


开发Prompt：为任务2.1生成Python代码，实现HL算法（g=3），标记K线数据的摆动高点H和低点L。要求：
- 使用Pandas `rolling`（窗口2g+1=7），向量化比较高低点。
- 输出DataFrame，新增列`is_high`（1/0）、`is_low`（1/0）。
- 确保最新K线[n-g,n]内HL不用于特征提取，避免数据泄露。
- 包含详细注释、异常处理（空数据/格式错误）、测试用例（验证1000条数据）。
- 全向量化，适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务2.1代码：
- 检查`is_high`/`is_low`标记是否符合g=3定义（H高于前后3根高点，L低于前后3根低点）。
- 验证最新K线[n-3,n]内HL未标记，杜绝数据泄露。
- 测试10M+数据运行时间<2分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：Pandas rolling向量化处理，单交易对（约100万条）<1秒。
安全提示：检查滞后性逻辑，避免未来数据泄露。

任务2.2: 峰谷去重

做什么：对HL序列去重，形成H L H L交错的峰谷序列。
怎么做：
遍历HL序列，识别连续H/L组，H取最高值（相等取最早），L取最低值（相等取最早）。
使用Pandas向量化实现（如groupby+idxmax/idxmin）。
确保最后一个峰谷基于相反HL确认（如H L H L L需下一H确认）。


开发Prompt：为任务2.2生成Python代码，对HL序列去重，形成H L H L交错的峰谷序列。要求：
- 输入含`is_high`/`is_low`的DataFrame，输出峰谷DataFrame（列：timestamp, price, is_peak）。
- 使用Pandas向量化（如`groupby`+`idxmax`/`idxmin`），H取最高值（相等取最早），L取最低值（相等取最早）。
- 确保最后一个峰谷基于相反HL确认，避免数据泄露。
- 包含详细注释、异常处理（空HL序列）、测试用例（验证1000条数据）。
- 全向量化，适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务2.2代码：
- 检查峰谷序列是否交错（H L H L），H为最高值，L为最低值。
- 验证最后一个峰谷基于相反HL确认（如H L H L L需下一H）。
- 测试10M+数据运行时间<2分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：Pandas groupby向量化，单交易对<1秒。
安全提示：检查去重逻辑，确保无未来数据泄露。

模块3: 关键价位
任务3.1: 计算ATR

做什么：为w根K线计算标准ATR，周期与w同步。
怎么做：
使用标准ATR公式：TR=max(high-low, |high-close_prev|, |low-close_prev|)，ATR为w周期均值。
使用Pandas rolling向量化计算TR和ATR。
输出DataFrame，新增列atr。


开发Prompt：为任务3.1生成Python代码，为w根K线计算标准ATR（周期=w）。要求：
- 使用公式`TR=max(high-low, |high-close_prev|, |low-close_prev|)`，ATR为w周期均值。
- 使用Pandas `rolling`向量化计算，新增列`atr`。
- 包含详细注释、异常处理（空数据/NaN）、测试用例（验证w=120）。
- 全向量化，适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务3.1代码：
- 检查`atr`列是否符合标准ATR公式（w周期均值）。
- 验证w=120时ATR计算正确，无NaN。
- 测试10M+数据运行时间<1分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：Pandas rolling向量化，单交易对<0.5秒。
安全提示：检查NaN处理，确保ATR计算准确。

任务3.2: 计算吸引力得分

做什么：为w根K线的2w个高低点计算吸引力得分（指数衰减）。
怎么做：
1. 对于w根K线的每个价格点（high或low），计算其吸引力得分
2. 每个点的价格区间：[price - band_width*ATR, price + band_width*ATR]
3. 统计剩余的w-1根K线的2w-2个价格点中，有多少个落在这个区间内
4. 对于每个落在区间内的价格点，计算得分：exp(-|price-target_price|/ATR)
5. 每个K线只计一次最高得分（high/low择一）
6. 最终得分 = 所有得分总和 / w，范围[0,1]
使用Pandas向量化实现（如apply+NumPy）。


开发Prompt：为任务3.2生成Python代码，为w根K线的2w个高低点计算吸引力得分。要求：
- 对于w根K线的每个价格点（high或low），计算其吸引力得分
- 每个点的价格区间：[price - band_width*ATR, price + band_width*ATR]
- 统计剩余的w-1根K线的2w-2个价格点中，有多少个落在这个区间内
- 对于每个落在区间内的价格点，计算得分：exp(-|price-target_price|/ATR)
- 每个K线只计一次最高得分（high/low择一）
- 最终得分 = 所有得分总和 / w，范围[0,1]
- 使用Pandas/NumPy向量化，band_width=0.1
- 包含详细注释、异常处理（NaN/ATR=0）、测试用例（w=120）
- 适配10M+数据，8G RAM
输出：代码块+性能/安全提示。


验收Prompt：验证任务3.2代码：
- 检查吸引力得分是否在[0,1]，符合指数衰减公式。
- 验证同一K线只计最高得分，band_width=0.1。
- 测试10M+数据运行时间<3分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（w=120，1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：NumPy向量化加速得分计算，单交易对<2秒。
安全提示：检查ATR=0处理，避免除零错误。

任务3.3: 筛选关键价位

做什么：筛选2w个高低点中得分最高且大于阈值（0.1）的key_1/key_0，满足(key_1-key_0)>ATR。
怎么做：
从吸引力得分DataFrame筛选得分>=0.1的点，取最高两个，标记为key_1（较高）、key_0（较低）。
验证(key_1-key_0)>ATR。
输出DataFrame，新增列key_level（key_1/key_0/NaN）。


开发Prompt：为任务3.3生成Python代码，筛选w根K线高低点的关键价位key_1/key_0。要求：
- 从吸引力得分DataFrame筛选得分>=0.1的点，取最高两个（key_1较高，key_0较低）。
- 验证(key_1-key_0)>ATR。
- 输出DataFrame，新增列`key_level`（key_1/key_0/NaN）。
- 使用Pandas向量化，阈值=0.1。
- 包含详细注释、异常处理（无合格点）、测试用例（w=120）。
- 适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务3.3代码：
- 检查`key_level`是否标记key_1/key_0，满足得分>=0.1且(key_1-key_0)>ATR。
- 验证无合格点时正确处理（NaN）。
- 测试10M+数据运行时间<1分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（w=120，1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：Pandas向量化筛选，单交易对<0.5秒。
安全提示：检查阈值逻辑，确保筛选准确。

任务3.4: 计算扩展价位

做什么：基于key_1/key_0计算扩展价位（-2,-1,2,3）。
怎么做：
公式：level_-1=key_0-(key_1-key_0)，level_-2=key_0-2*(key_1-key_0)，level_2=key_1+(key_1-key_0)，level_3=key_1+2*(key_1-key_0)。
输出DataFrame，新增列level_-2、level_-1、level_2、level_3。


开发Prompt：为任务3.4生成Python代码，基于key_1/key_0计算扩展价位。要求：
- 公式：`level_-1=key_0-(key_1-key_0)`，`level_-2=key_0-2*(key_1-key_0)`，`level_2=key_1+(key_1-key_0)`，`level_3=key_1+2*(key_1-key_0)`。
- 输出DataFrame，新增列`level_-2`、`level_-1`、`level_2`、`level_3`。
- 使用Pandas向量化，处理NaN。
- 包含详细注释、异常处理（无key_1/key_0）、测试用例（w=120）。
- 适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务3.4代码：
- 检查`level_-2`、`level_-1`、`level_2`、`level_3`是否按公式计算。
- 验证NaN处理正确（无key_1/key_0时）。
- 测试10M+数据运行时间<0.5分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（w=120，1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：Pandas向量化计算，单交易对<0.2秒。
安全提示：检查NaN处理，避免无效价位。

模块4: 回测
任务4.1: 模拟交易逻辑

做什么：模拟中性挂单（扩展价位2/-1），盈亏比3:1，手续费0.05%。
怎么做：
在扩展价位2挂空单（SL=level_3，TP=level_-1），扩展价位-1挂多单（SL=level_-2，TP=level_2）。
一边成交则取消另一边，模拟限价单。
计算盈亏，扣除0.05%手续费。
输出交易记录DataFrame（列：timestamp, symbol, direction, entry_price, exit_price, profit）。


开发Prompt：为任务4.1生成Python代码，模拟中性挂单交易逻辑。要求：
- 在扩展价位2挂空单（SL=level_3，TP=level_-1），扩展价位-1挂多单（SL=level_-2，TP=level_2）。
- 一边成交取消另一边，模拟限价单，盈亏比3:1，手续费0.05%。
- 输出交易记录DataFrame（列：timestamp, symbol, direction, entry_price, exit_price, profit）。
- 使用Pandas向量化，逐K线更新价位。
- 包含详细注释、异常处理（无价位/无效订单）、测试用例（1000条数据）。
- 适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务4.1代码：
- 检查挂单逻辑是否在扩展价位2/-1触发，SL/TP符合3:1盈亏比。
- 验证一边成交取消另一边，手续费0.05%。
- 检查交易记录DataFrame格式（timestamp, symbol, direction, entry_price, exit_price, profit）。
- 测试10M+数据运行时间<5分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：Pandas向量化模拟，单交易对<3秒。
安全提示：检查订单逻辑，确保无重复成交。

任务4.2: 贝叶斯优化

做什么：对w=[120,240]、band_width=[0.05,0.15]、阈值=[0.05,0.2]进行贝叶斯优化，评估夏普比率。
怎么做：
使用scikit-optimize的gp_minimize实现贝叶斯优化。
目标函数：运行任务4.1，计算夏普比率（年化收益/波动率）。
分批处理交易对（每批1个），减少内存占用。


开发Prompt：为任务4.2生成Python代码，使用贝叶斯优化参数w=[120,240]、band_width=[0.05,0.15]、阈值=[0.05,0.2]。要求：
- 使用`scikit-optimize`的`gp_minimize`，目标为最大化夏普比率。
- 调用任务4.1的交易逻辑，计算年化收益/波动率。
- 分批处理交易对（每批1个），适配8G RAM。
- 包含详细注释、异常处理（无效参数）、测试用例（单交易对）。
- 适配10M+数据。
输出：代码块+性能/安全提示。


验收Prompt：验证任务4.2代码：
- 检查贝叶斯优化是否覆盖w=[120,240]、band_width=[0.05,0.15]、阈值=[0.05,0.2]。
- 验证夏普比率计算正确（年化收益/波动率）。
- 测试10M+数据运行时间<30分钟（10个交易对）。
- 确认分批处理有效，内存占用<8G。
- 验证测试用例通过（单交易对）。
输出：通过/不通过，列出问题及修改建议。


性能提示：分批优化，单交易对<3分钟，总时间<30分钟。
安全提示：检查参数边界，避免无效组合。

模块5: 特征工程
任务5.1: 提取扩展价位比例

做什么：计算50个峰谷的扩展价位比例：(peak_valley_price-key_0)/(key_1-key_0)。
怎么做：
从峰谷序列提取最近50个峰谷。
计算比例，输出特征DataFrame（列：timestamp, peak_valley_price, ratio）。
使用Pandas向量化处理。


开发Prompt：为任务5.1生成Python代码，计算最近50个峰谷的扩展价位比例。要求：
- 从峰谷序列提取最近50个峰谷。
- 计算比例：`(peak_valley_price-key_0)/(key_1-key_0)`。
- 输出特征DataFrame（列：timestamp, peak_valley_price, ratio）。
- 使用Pandas向量化，处理NaN。
- 包含详细注释、异常处理（不足50个峰谷）、测试用例（1000条数据）。
- 适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务5.1代码：
- 检查特征DataFrame是否包含50个峰谷的正确比例。
- 验证NaN处理正确（key_1=key_0时）。
- 测试10M+数据运行时间<1分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：Pandas向量化，单交易对<0.5秒。
安全提示：检查除零处理，避免无效比例。

任务5.2: Z-Score归一化成交量

做什么：对成交量进行Z-Score归一化，突出异常值。
怎么做：
使用Pandas计算成交量的均值和标准差，Z-Score=(volume-mean)/std。
输出DataFrame，新增列volume_zscore。


开发Prompt：为任务5.2生成Python代码，对K线成交量进行Z-Score归一化。要求：
- 计算Z-Score=(volume-mean)/std，突出异常值。
- 输出DataFrame，新增列`volume_zscore`。
- 使用Pandas向量化，处理NaN。
- 包含详细注释、异常处理（std=0）、测试用例（1000条数据）。
- 适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务5.2代码：
- 检查`volume_zscore`是否正确计算，突出异常值。
- 验证NaN/std=0处理正确。
- 测试10M+数据运行时间<0.5分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：Pandas向量化，单交易对<0.2秒。
安全提示：检查std=0处理，避免除零错误。

模块6: 机器学习
任务6.1: 样本准备与SMOTE

做什么：准备特征（50个峰谷比例+成交量Z-Score）和标签（交易盈亏），使用SMOTE平衡样本。
怎么做：
合并任务5.1和5.2的特征，标签从任务4.1的交易记录（profit>0为1，<=0为0）。
使用Scikit-learn的SMOTE平衡正负样本。
输出训练集DataFrame（特征+标签）。


开发Prompt：为任务6.1生成Python代码，准备特征和标签，使用SMOTE平衡样本。要求：
- 合并50个峰谷比例（任务5.1）和成交量Z-Score（任务5.2）。
- 标签从交易记录（profit>0为1，<=0为0）。
- 使用Scikit-learn的SMOTE平衡样本。
- 输出训练集DataFrame（特征+标签）。
- 包含详细注释、异常处理（空数据/样本不足）、测试用例（1000条数据）。
- 适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务6.1代码：
- 检查训练集DataFrame是否包含50个峰谷比例+成交量Z-Score+标签。
- 验证SMOTE平衡后正负样本比例接近1:1。
- 测试10M+数据运行时间<5分钟。
- 确认代码向量化，内存占用<8G。
- 验证测试用例通过（1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：SMOTE分批处理，单交易对<3秒。
安全提示：检查样本泄露，确保标签基于历史数据。

任务6.2: RandomForest训练

做什么：使用RandomForestClassifier训练模型，验证交易规则。
怎么做：
使用Scikit-learn的RandomForestClassifier（n_estimators=100）。
划分训练/测试集（80/20），评估准确率、F1分数。
保存模型到models/rf_model.pkl。


开发Prompt：为任务6.2生成Python代码，使用RandomForestClassifier训练模型。要求：
- 使用Scikit-learn的`RandomForestClassifier`（n_estimators=100）。
- 划分训练/测试集（80/20），计算准确率、F1分数。
- 保存模型到`models/rf_model.pkl`。
- 包含详细注释、异常处理（空数据）、测试用例（1000条数据）。
- 适配10M+数据，8G RAM。
Output：代码块+性能/安全提示。


验收Prompt：验证任务6.2代码：
- 检查模型是否训练成功，准确率/F1分数合理。
- 验证模型保存到`models/rf_model.pkl`。
- 测试10M+数据运行时间<10分钟。
- 确认训练/测试集划分正确，无数据泄露。
- 验证测试用例通过（1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：RandomForest分批训练，单交易对<5秒。
安全提示：检查训练集无未来数据。

模块7: 交易规则
任务7.1: 动态更新价位

做什么：逐K线更新关键价位和扩展价位。
怎么做：
每新增K线，滑动窗口w，调用任务3.1-3.4重新计算ATR、关键价位、扩展价位。
输出DataFrame，更新key_level、level_-2、level_-1、level_2、level_3。


开发Prompt：为任务7.1生成Python代码，逐K线更新关键价位和扩展价位。要求：
- 每新增K线，滑动窗口w，调用任务3.1-3.4计算ATR、关键价位、扩展价位。
- 输出DataFrame，更新`key_level`、`level_-2`、`level_-1`、`level_2`、`level_3`。
- 使用Pandas向量化，处理NaN。
- 包含详细注释、异常处理（无价位）、测试用例（1000条数据）。
- 适配10M+数据，8G RAM。
输出：代码块+性能/安全提示。


验收Prompt：验证任务7.1代码：
- 检查关键价位和扩展价位是否逐K线更新正确。
- 验证NaN处理正确。
- 测试10M+数据运行时间<5分钟。
- 确认代码向量化，无for循环。
- 验证测试用例通过（1000条数据）。
输出：通过/不通过，列出问题及修改建议。


性能提示：Pandas向量化，单交易对<3秒。
安全提示：检查滑动窗口逻辑，确保无未来数据。

模块8: 环境配置
任务8.1: 配置Poetry依赖

做什么：生成pyproject.toml，包含CCXT、Pandas、Scikit-learn、scikit-optimize等依赖。
怎么做：
创建pyproject.toml，指定Python 3.13，添加依赖：ccxt, pandas, numpy, scikit-learn, scikit-optimize。
提醒Cursor AI运行poetry install并检查ARM兼容性。


开发Prompt：为任务8.1生成`pyproject.toml`文件，配置项目依赖。要求：
- 指定Python 3.13，添加依赖：`ccxt`, `pandas`, `numpy`, `scikit-learn`, `scikit-optimize`。
- 包含详细注释，说明每个依赖用途。
- 提醒运行`poetry install`，检查M2 Mac mini ARM兼容性。
- 保存到`pyproject.toml`。
输出：文件内容+性能/安全提示。


验收Prompt：验证任务8.1的`pyproject.toml`：
- 检查是否包含`ccxt`, `pandas`, `numpy`, `scikit-learn`, `scikit-optimize`。
- 验证Python 3.13兼容性声明。
- 确认`poetry install`成功，无ARM兼容性问题。
- 检查文件注释是否清晰。
输出：通过/不通过，列出问题及修改建议。


性能提示：Poetry安装<1分钟。
安全提示：检查依赖版本，避免安全漏洞。

下一行动项

上传GitHub：将项目结构和代码上传至GitHub，推荐仓库名为interval_trading。
Cursor配置：
创建两个Cursor窗口，一个运行开发Prompt（代码开发Agent），另一个运行验收Prompt（代码验收Agent）。
运行任务8.1的poetry install，确保环境就绪。


执行任务：按模块顺序执行任务（1.1→8.1），建议从数据获取开始，逐步验证。
性能监控：运行10M+数据时，监控M2 Mac mini内存使用（<8G），必要时调整分批大小。

示例代码（任务1.2）
以下是任务1.2的示例代码，供参考：
import ccxt
import pandas as pd
import time
from datetime import datetime
import json
import os

def fetch_kline_data(symbol, start_date, end_date, timeframe='5m', batch_size=1000):
    """拉取Binance K线数据，保存为CSV"""
    exchange = ccxt.binance({'enableRateLimit': True})
    start_ts = int(datetime.strptime(start_date, '%Y-%m-%d').timestamp() * 1000)
    end_ts = int(datetime.strptime(end_date, '%Y-%m-%d').timestamp() * 1000)
    data = []
    
    while start_ts < end_ts:
        try:
            batch = exchange.fetch_ohlcv(symbol, timeframe, since=start_ts, limit=batch_size)
            if not batch:
                break
            data.extend(batch)
            start_ts = batch[-1][0] + 1
            time.sleep(1)  # 避免API限频
        except Exception as e:
            print(f"Error: {e}, retrying in 5s...")
            time.sleep(5)
    
    df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    os.makedirs('data', exist_ok=True)
    df.to_csv(f'data/{symbol.replace("/", "_")}_5m.csv', index=False)
    return df

# 测试用例
if __name__ == "__main__":
    symbol = "BTC/USDT"
    df = fetch_kline_data(symbol, '2023-06-01', '2025-06-30')
    assert not df.empty, "DataFrame is empty"
    assert df.columns.tolist() == ['timestamp', 'open', 'high', 'low', 'close', 'volume'], "Invalid columns"
    print("Test passed")

性能提示：分批拉取（1000条/次），单交易对约200MB，运行时间<5分钟。安全提示：确保公共API调用，无密钥泄露。